'use strict';

var util = require('util');
var EventEmitter = require('events').EventEmitter;

/**
 *
 * IO Box
 *
 * @param {String} name
 */
var IOBox = function (name, args, returns) {

  if (!(this instanceof IOBox)) {
    return new IOBox(name, args, returns);
  }

  EventEmitter.apply(this, arguments);

  this.name = name || 'UNNAMED';

  // to ensure correct order
  this._keys = [];

  args = args || [];
  returns = returns || [];

  this.setup(args, returns);

};

util.inherits(IOBox, EventEmitter);

/**
 *
 * Setup
 *
 * @param {Array} args
 * @param {Array} returns
 */
IOBox.prototype.setup = function (args, returns) {

  var i;

  this.args = {};
  this.returns = [];
  this.fn = undefined;

  // setup the empty input arguments object
  for (i = 0; i < args.length; i++) {
    this.addArg(args[i], undefined);
  }

  for (i = 0; i < returns.length; i++) {
    this.addReturn(returns[i]);
  }
};

/**
 *
 * Used to access the properties at the top level,
 * but still be able to get all relevant arguments
 * at once using this.args
 *
 * @param {String} key
 * @param {Mixed} initial
 */
IOBox.prototype.addArg = function (key, initial) {

  Object.defineProperty(this, key, {
    set: function (val) {
      this.args[key] = val;
    },
    get: function () {
      return this.args[key];
    }
  });

  this._keys.push(key);

  this[key] = initial; // can be undefined

};

IOBox.prototype.addReturn = function (r) {
  if (this.returns.indexOf(r) === -1) {
    if (this._keys.indexOf(r) !== -1) {
      this.returns.push(r);
    }
    else {
      throw Error([
        'Output `',
        r,
        '` is not one of',
        this._keys.join(', ')
      ].join(' '));
    }
  }
};

/**
 *
 * Sets a property of the sandbox.
 * Because the keys determine what arguments will
 * be generated for the function, it is important
 * we keep some kind of control over what is set.
 *
 * @param {String} key
 * @param {Mixed} value
 *
 */
IOBox.prototype.set = function (key, value) {

  if (this.args.hasOwnProperty(key)) {
    this.args[key] = value;
  }
  else {
    throw new Error([
      'Will not set unknown property',
      key
    ].join(' '));
  }
};

/**
 *
 * Compiles and returns the generated function.
 *
 * @param {String} fn
 * @param {Boolean} asObject
 * @return {String}
 */
IOBox.prototype.compile = function (fn, asObject) {

  if (!this.code) {
    this.generate(fn ? fn.trim() : fn, asObject);
  }

  this.fn = new Function(this.code)();

  return this.fn;

};

/**
 *
 * Fill with a precompiled function
 *
 * Return type in this case is determined by compiled function
 *
 * @param {String} fn
 * @return {String}
 */
IOBox.prototype.fill = function (fn) {

  // argument signature check?

  this.fn = fn;

  return this.fn;

};

/**
 *
 * Wraps the function in yet another function
 *
 * This way it's possible to get the original return.
 *
 * @param {String} fn
 * @return {String}
 */
IOBox.prototype._returnWrap = function (fn) {
  return ['function() {', fn, '}.call(this)'].join('\n');
};
/**
 *
 * Clear generated code
 */
IOBox.prototype.clear = function () {
  this.code = null;
};

/**
 *
 * Generates the function.
 *
 * This can be used directly
 *
 * @param {String} fn
 * @param {Boolean} asObject
 * @return {String}
 */
IOBox.prototype.generate = function (fn, asObject) {

  this.code = [
    'return function ',
    this.name,
    '(',
    this._keys.join(','),
    ') {\n',
    'var r = ', // r goes to 'return'
    this._returnWrap(fn),
    '; return ',
    asObject ? this._asObject() : this._asArray(),
    '; }'
  ].join('');

  return this.code;
};

/**
 *
 * Return output as array.
 *
 * @return {String}
 */
IOBox.prototype._asArray = function () {
  return '[' + this.returns.join(',') + ',r]';
};

/**
 *
 * Return output as object.
 *
 * @return {String}
 */
IOBox.prototype._asObject = function () {
  var ret = [];
  for (var i = 0; i < this.returns.length; i++) {
    ret.push(this.returns[i] + ':' + this.returns[i]);
  }
  ret.push('return:' + 'r');

  return '{' + ret.join(',') + '}';
};

/**
 *
 * Renders the function to string.
 *
 * @return {String}
 */
IOBox.prototype.toString = function () {
  if (this.fn) return this.fn.toString();
  return this.fn;
};

/**
 *
 * Runs the generated function
 *
 * @param {Mixed} bind   Context to bind to the function
 * @return {Mixed}
 */
IOBox.prototype.run = function (bind) {

  var v = [];
  var k;

  for (k in this.args) {
    if (this.args.hasOwnProperty(k)) {
      v[this._keys.indexOf(k)] = this.args[k];
    }
    else {
      throw new Error('unknown input ' + k);
    }
  }

  // returns the output, format depends on the `compile` step
  return this.fn.apply(bind, v);

};

module.exports = IOBox;
