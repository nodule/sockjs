#!/usr/bin/env node
'use strict';

var fs = require('fs'),
  path = require('path'),
  exec = require('child_process').exec,
  request = require('superagent'),
  schema = require('chix-flow').Schema,
  Actor = require('chix-flow').Actor,
  program = require('commander'),
  pkg = require('../package.json'),
  version = pkg.version,
  glob = require('glob'),
  jsonGate = require('json-gate'),
  nodeSchema = jsonGate.createSchema(schema.Node),
  mapSchema = jsonGate.createSchema(schema.Map);

var nodes = [];

var deploysTo = [
  'https://serve-chix.rhcloud.com/nodes',
  'http://localhost:5000/nodes'
];

var gitDir = '/home/rhalff/git';

function platformUpdate() {

  var cwd  = process.cwd();
  var repo = cwd.split('/').pop();

  var dir = path.resolve(gitDir + '/chix-platform/src/', repo);

  console.log('Perform platform update');
  var cmds = [
    'chix-compile',
    'git add .',
    'git commit -m "update"',
    'git push origin master',
    'cd ' + dir,
    'git pull origin master',
    'cd ../../',
    './build',
    'git add .',
    'git commit -m "update ' + repo + '"',
    'git push origin master',
    'cd ' + gitDir + '/chix-website'
  ];

  // also publish website
  if(program.publish) {
    cmds.push('./publish');
  }

  exec(cmds.join(';'), function(err, stdout, stderr) {

      if(err) console.log(err);
      if(stderr) console.log(stderr);
      console.log(stdout);
      process.chdir(cwd);

      deploysTo.forEach(function(deployTo) {

        console.log('Deploying to', deployTo);

        // send to serve.chix.io
        request
        .put(deployTo)
        .set('Authorization', 'Bearer ' + process.env.CHIX_TOKEN)
        .send(nodes)
        .end(function (err, res) {

          if(err) {
            console.log('Error:', err);
          } else {
            console.log('Deployed', res.text);
          }

        });

      });

    });

}

var gpattern = '/nodes/**/node.js*';

program
  .version(version)
  .usage('[options]')
  .option('-g, --glob', 'globbing pattern default: ' + gpattern)
  .option('-r, --run-twigs', 'run the twigs, only use this for non-listening stuff')
  .option('-d, --deploy', 'deploy nodes')
  .option('-t, --deployTo [url]', 'server to deploy to')
  .option('-n, --test [node]', 'test node')
  .option('-p, --publish', 'also publish website')
  .option('-b, --base-dir [name]', 'base dir')
  .option('-v, --verbose', 'be verbose')
  .parse(process.argv);

// err, dirname is a bit weird gpattern should solve that.
var dirname = program.baseDir ? program.baseDir : process.cwd();

if(program.deployTo) {
  deploysTo.push(program.deployTo);
}

gpattern = program.glob || gpattern;

var c;

var pkg = require(path.resolve(dirname + '/package.json'));

if(!pkg.chix) {
  throw new Error([
    'Package',
    pkg.name,
    'does not have a chix section'
  ].join(' '));
}

var verbose = program.verbose;

function runTest(test, node) {

  var actor = new Actor();
  actor.addNodeDefinition(node);
  actor.createNode(node);
  actor.createNodes();

}

if(verbose) {
  console.log('Globbing' + dirname + gpattern);
}

glob(dirname + gpattern, function(err, files) {

  var parts, nodule, ext, i;
  var node = {};

  for(i = 0; i < files.length; i++) {

    parts = files[i].split('/');
    nodule = parts[1];
    ext = path.extname(files[i]);

    if(verbose) {
      console.log('Reading file:', files[i]);
    }

    c = fs.readFileSync(files[i]).toString();

    if(ext === '.js') {
      node.fn  = c; // warning: relies on .js before .json
    } else if(ext === '.json') {

      var json = JSON.parse(c);
      json.fn = node.fn; // crappy

      // also save env
      if(node.env) {
        json.env = node.env;
      } else if(pkg.chix.env) {
        json.env = pkg.chix.env;
      }
      // Hacky, test the node.
      if(program.test && program.test === nodule) {

        nodeSchema.validate(json);
        var testFile = ['./nodes', nodule, 'test.json'].join('/');
        if(fs.exists(testFile)) {
          runTest(
            json,
            JSON.parse(fs.readFileSync(testFile))
          );
        }

      } else {

        // validate json
        nodeSchema.validate(json);
        if(verbose) {
          console.log('validated:', files[i]);
        }

        nodes.push(json);

      }

      node = {};

    }

  }

  if(program.deploy) {

    platformUpdate();

  } else {

    // check twigs, todo: make the structure less hacky
    glob(dirname + '/twigs/*.json*', function(err, files) {

      // nodes within this twig are allowed to incorparate other
      // namespaces, but this twig belongs to this namespace
      for(var i = 0; i < files.length; i++) {
        var flow = require(files[i]);
        // validate it
        mapSchema.validate(flow);

        if(program.runTwigs) {
          // A bit of wild west, take caution with enabling runTwigs.
          // also note, that this will run (very) async.
          var actor = new Actor();
          actor.addMap(flow);
          actor.createNodes();
          actor.run();
        }
      }

    });
  }

});
