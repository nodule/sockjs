'use strict';
var Packet = require('../packet');
var EventEmitter = require('events').EventEmitter;
var util = require('util');
var CHI = require('chix-chi');
var uuid = require('uuid').v4;
var handleIndex = require('./indexHandler');
var isPlainObject = require('is-plain-object');
var DefaultQueueManager = require('../queue/defaultManager');
var debug = require('debug')('chix:io');

function cloneData(p, type) {
  /* function type does not mean the data itself is directly
   * a function, it can also be a plain object holding
   * functions. so what is specified is leading.
   */
  if (type === 'function') {
    return;
  }
  if (typeof p.data === 'object' && isPlainObject(p.data)) {
    p.data = JSON.parse(JSON.stringify(p.data));
  }
}

/**
 *
 * This is the IoMap Handler
 *
 * It should know:
 *
 *  - the connections.
 *  - address of the source UUID + port name
 *  - address of the target UUID + port name
 *  - relevant source & target connection settings.
 *
 * Connection settings can overlap with port settings.
 * Connection settings take precedence over port settings,
 * althought this is not set in stone.
 *
 * @constructor
 * @public
 *
 **/

function IoMapHandler() {
  this.CHI = new CHI();
  // todo: create maps from each of these and wrap them in a connections map
  // so all there wil be is this.connections.
  // connections.byTarget, connections.bySource etc.
  this.targetMap = {};
  this.connections = {};
  this.sourceMap = {};
  this.syncedTargetMap = {};
  this.pointerPorts = {};
  this._shutdown = false;
  this.addQueueManager(
    new DefaultQueueManager(this.receiveFromQueue.bind(this))
  );
  this.addCHI(this.CHI);
}

util.inherits(IoMapHandler, EventEmitter);

IoMapHandler.prototype.addCHI = function(CHI) {
  this.CHI = CHI;
  this.CHI.on('begingroup', this.beginGroup.bind(this));
  this.CHI.on('endgroup', this.sendGroup.bind(this));
  this.CHI.on('collected', this.collected.bind(this));
  this.CHI.on('synced', this.sendSynced.bind(this));
};

/**
 *
 * Connects ports together using the link information provided.
 *
 *  @param {xLink} link
 * @api public
 */
IoMapHandler.prototype.connect = function(link) {
  if (!link.source) {
    throw Error('Link requires a source');
  }
  if (!link.source.pid) {
    link.source.pid = link.source.id;
  }
  // TODO: quick fix, which never works..
  // ioHandler is the only one assigning these..
  // a link with ioid set should be rejected..
  if (!link.ioid) {
    link.ioid = uuid();
  }
  if (!link.target) {
    throw Error('Link requires a target');
  }
  if (!link.target.pid) {
    link.target.pid = link.target.id;
  }
  // register the connection
  this.connections[link.ioid] = link;
  if (!this.targetMap[link.source.pid]) {
    this.targetMap[link.source.pid] = [];
  }
  this.targetMap[link.source.pid].push(link);
  if (!this.sourceMap[link.target.pid]) {
    this.sourceMap[link.target.pid] = [];
  }
  this.sourceMap[link.target.pid].push(link);
  // build the syncedTargetMap, it contains a port array
  // (the group that wants a sync with some originId
  if (link.target.has('sync')) {
    if (!this.syncedTargetMap[link.target.pid]) {
      this.syncedTargetMap[link.target.pid] = {};
    }
    if (!this.syncedTargetMap[link.target.pid][link.target.get('sync')]) {
      this.syncedTargetMap[link.target.pid][link.target.get('sync')] = [];
    }
    this.syncedTargetMap[link.target.pid][link.target.get('sync')]
      .push(link.target.port);
    debug(
      '%s: syncing source port `%s` with target port %s',
      link.ioid, link.target.get('sync'), link.target.port
    );
  }
  if (link.source.get('pointer')) {
    if (!this.pointerPorts[link.source.pid]) {
      this.pointerPorts[link.source.pid] = [];
    }
    this.pointerPorts[link.source.pid].push(link.source.port);
    debug('%s: added pointer port `%s`', link.ioid, link.source.port);
  }

  debug('%s: link connected', link.ioid);

  this.emit('connect', link);
};

// TODO: ugly, source & target map
// should be one central place of registration.
// now a link is in two places.
IoMapHandler.prototype.get = function(link) {
  if (this.sourceMap[link.target.pid]) {
    return this.sourceMap[link.target.pid];
  }
};

IoMapHandler.prototype.lock = function(link) {
  debug('%s: lock', link.ioid);
  this.queueManager.lock(link.ioid);
};

IoMapHandler.prototype.unlock = function(link) {
  debug('%s: unlock', link.ioid);
  this.queueManager.unlock(link.ioid);
};

IoMapHandler.prototype.accept = function(link /*, p*/ ) {
  debug('%s: accept', link.ioid);
  // update the fill count.
  // normally belongs to a Port Object.
  link.fills++;
  // re-open queue for this link.
  if (this.queueManager.isLocked(link.ioid)) {
    // freePort will do this now.
    this.queueManager.unlock(link.ioid);
  }
};

IoMapHandler.prototype.reject = function(err, link, p) {
  // update the reject count.
  // normally belongs to a Port Object.
  link.rejects++;
  this.queueManager.lock(link.ioid);
  // Do not put it back in queue if there was a *real* error
  // Default error is `false`, which is just a normal reject.
  if (util.isError(err)) {
    debug('%s: reject (error)', link.ioid);
    // stays locked.
  }
  else {
    // put it back in queue.
    debug('%s: reject (requeue)', link.ioid);
    this.queueManager.unshift(link.ioid, p);
    // unlock again
    // stay locked, untill unlocked
    // IMPORTANT! unlock logic must just work
    // otherwise it goes beserk.
    // this.queueManager.unlock(link.ioid);
    // The process manager is listening for the node
    // which is already in error state
    // this.emit('error', err);
  }
};

/**
 *
 *  Disconnects a link
 *
 *  @param {xLink} link
 */
IoMapHandler.prototype.disconnect = function(link) {
  var src;
  var tgt;
  // unregister the connection
  if (this.connections.hasOwnProperty(link.ioid)) {
    delete this.connections[link.ioid];
  }
  else {
    throw Error('Cannot disconnect an unknown connection');
  }
  if (this.targetMap[link.source.pid]) {
    src = this.targetMap[link.source.pid];
    src.splice(src.indexOf(link), 1);
    if (src.length === 0) {
      delete this.targetMap[link.source.pid];
    }
  }
  if (this.sourceMap[link.target.pid]) {
    tgt = this.sourceMap[link.target.pid];
    tgt.splice(tgt.indexOf(link), 1);
    if (tgt.length === 0) {
      delete this.sourceMap[link.target.pid];
    }
  }
  if (this.syncedTargetMap[link.target.pid]) {
    tgt = this.syncedTargetMap[link.target.pid];
    tgt.splice(src.indexOf(link.target.port), 1);
    if (tgt.length === 0) {
      delete this.syncedTargetMap[link.target.pid];
    }
  }
  if (this.pointerPorts[link.source.pid]) {
    src = this.pointerPorts[link.source.pid];
    src.splice(src.indexOf(link.source.port), 1);
    if (src.length === 0) {
      delete this.pointerPorts[link.source.pid];
    }
  }
  debug('%s: disconnected', link.ioid);
  // prevents iip bug, where iip is still queued.
  // disconnect does not correctly take queueing into account.
  delete link.ioid;

  // used by actor to close ports
  this.emit('disconnect', link);
};

/**
 *
 * Get all node ids that target this node.
 *
 * TODO: return .id's not .pid ah well..
 *
 * @param {String} pid
 * @return {Array}
 * @api public
 */
IoMapHandler.prototype.getSourcePids = function(pid) {
  var i;
  var src;
  var ids = [];
  if (this.sourceMap.hasOwnProperty(pid)) {
    for (i = 0; i < this.sourceMap[pid].length; i++) {
      src = this.sourceMap[pid][i].source;
      if (ids.indexOf(src.pid) === -1) {
        ids.push(src.pid);
      }
    }
  }
  return ids;
};

/**
 *
 * Get all nodes that use this node as a source .
 *
 * @param {String} pid
 * @return {Array}
 * @api public
 */
IoMapHandler.prototype.getTargetPids = function(pid) {
  var i;
  var ids = [];
  if (this.targetMap.hasOwnProperty(pid)) {
    for (i = 0; i < this.targetMap[pid].length; i++) {
      ids.push(this.targetMap[pid][i].target.pid);
    }
  }
  return ids;
};

/**
 *
 * Get all node ids this node depends on.
 *
 * @param {String} pid
 * @return {Array}
 * @api public
 */
IoMapHandler.prototype.getAncestorPids = function(pid) {
  var i;
  var ids = [];
  var aIds = [];
  var u = [];
  aIds = ids = this.getSourcePids(pid);
  for (i = 0; i < ids.length; i++) {
    aIds = aIds.concat(this.getAncestorPids(ids[i]));
  }
  for (i = 0; i < aIds.length; i++) {
    if (u.indexOf(aIds[i]) === -1) {
      u.push(aIds[i]);
    }
  }
  return u;
};
IoMapHandler.prototype.reset = function(cb) {
  var self = this;
  this._shutdown = true;
  this.queueManager.reset(function() {
    // All writes should stop, queuemanager resets.
    // or maybe should wait for queuemanager to be empty.
    if (cb) {
      cb();
    }
    self._shutdown = false;
  });
};

IoMapHandler.prototype.receiveFromQueue = function(ioid, p) {
  debug('%s: receive from queue', ioid);
  if (this.connections.hasOwnProperty(ioid)) {
    this.send(this.connections[ioid], p);
  }
};

/**
 *
 * The method to provide input to this io handler.
 *
 * @param {Link} link
 * @param {Packet} p
 *
 */
IoMapHandler.prototype.send = function(link, p) {
  if (link.source.has('pointer')) { // is just a boolean
    debug('%s: handling pointer', link.ioid);
    var identifier;
    var pp;
    // THIS IS NOT THE PLACE TO CLONE, but let's try it.
    // WILL BREAK ANYWAY WITH references.
    //
    // Ok, what is _the_ location to clone.
    //
    // A package going different routes must clone.
    //
    // p = p.clone();
    // Create an identifier
    pp = this.getPointerPorts(link.source.pid);
    pp.unshift(link.source.pid);
    identifier = pp.join('-');
    // The source node+port are pointed to.
    // The packet has it's chi updated with the
    // source.pid as key and an assigned item id as value
    //
    this.CHI.pointer(
      link.source.pid,
      link.source.port,
      p,
      identifier
    );
  }
  if (link.target.has('sync')) {
    debug('%s: handling sync port', link.ioid);
    var syncPorts = this.getSyncedTargetPorts(link.target);
    this.CHI.sync(
      //link.target,
      link,
      link.target.get('sync'), // originId
      // TODO: should just only accept the packet
      p,
      syncPorts
    );
    // always return, react on CHI.on('synced')
    return;
  }
  this.__sendData(link, p);
};

/**
 *
 * The method to provide input to this io handler.
 *
 * Ok, what misses here is info on how to find the actor
 * Who needs the information
 *
 *
 * Actor:
 *
 *  ioHandler.listenTo(Object.keys(this.nodes),
 *
 * @param {Connector} target
 * @param {object} input
 * @param {object} chi
 * @private
 */

/*
 *
 * Send Data
 *
 * @param {xLink} link - Link to write to
 * @param {Any} data - The input data
 * @private
 */
IoMapHandler.prototype.__sendData = function(link, p) {
  if (this._shutdown) {
    // TODO:: probably does not both have to be dropped
    // during __sendData *and* during output
    this.drop(p, link);
  }
  else {
    var data;
    if (link.target.has('cyclic') &&
      Array.isArray(p.data) // second time it's not an array anymore
    ) {
      debug('%s: cycling', link.ioid);
      // grouping
      // The counter part will be 'collect'
      var g = this.CHI.group();
      if (p.data.length === 0) {
        return false;
      }
      // make a copy otherwise if output goes to several ports
      // it will receive a popped version.
      //
      // Ok, this has to be removed and source ports should set as cyclic.
      // Not target ports.
      data = JSON.parse(JSON.stringify(p.data));
      var i;
      for (i = 0; i < data.length; i++) {
        // create new packet
        var newp = new Packet(data[i]);
        // this is a copy taking place..
        newp.set('chi', p.chi ? JSON.parse(JSON.stringify(p.chi)) : {});
        g.item(newp.chi);
        this.queueManager.queue(link.ioid, newp);
      }
      // we are done grouping now.
      g.done();
      return; // RETURN
    }
    var cp = p; // current packet
    // too bad cannot check the receiver type.
    // TODO: maybe have p.type() so the packet can tell it's content type.
    // plain object is a bit harder though would have to introduce
    // PLAIN_OBJECT type or something
    // The packet itself should tell what it is,
    // not checking p.data externally like this.
    /*
    if (typeof cp.data === 'object' && isPlainObject(cp.data)) {
      cp.data = JSON.parse(JSON.stringify(cp.data));
    }
    */
    cloneData(cp, 'function');
    // TODO: not sure if index should stay within the packet.
    if (link.source.has('index') && !cp.hasOwnProperty('index')) {
      //if (link.source.has('index')) {
      // above already cloned if possible.
      // what is not cloned is CHI, so could cause a problem..
      cp.chi = JSON.parse(JSON.stringify(cp.chi));
      cp = p.clone(false); // important!
      if (undefined === cp.data[link.source.get('index')]) {
        // this is allowed now for async array ports.
        // the component will only send one index at a time.
        // this is useful for routing.
        // maybe only enable this with a certain setting on the port later on.
        debug('%s: INDEX UNDEFINED %s', link.ioid, link.source, cp.data);
        // does this stop the loop, because it should not.
        return; // nop
      }
      else {
        cp.data = handleIndex(link, cp);
      }
    }
    // TODO: probably just remove this emit. (chix-runtime is using it)
    this.emit('data', {
      link: link,
      data: cp.data // only emit the data
    });

    debug('%s: writing packet', link.ioid);

    link.write(cp);
    this.emit('receive', link);
  }
};

/**
 *
 * Handles the output of every node.
 *
 * This comes directly from the Actor, whom got it from the node.
 *
 * The emit should maybe come from the link write.
 *
 * If there is chi it will be passed along.
 *
 * @param {NodeEvent} event
 * @api public
 */
IoMapHandler.prototype.output = function(event) {
  // used by monitors
  this.emit('output', event);
  this.receive(event.node, event.port, event.out, event.action);
};

/**
 *
 * Monitor event types
 *
 * Optionally provided with a pid.
 *
 */
IoMapHandler.prototype.monitor = function(eventType, pid, cb) {
  this.__monitor(eventType, pid, cb, 'on');
};

IoMapHandler.prototype.monitorOnce = function(eventType, pid, cb) {
  this.__monitor(eventType, pid, cb, 'once');
};

IoMapHandler.prototype.__monitor = function(eventType, pid, cb, how) {
  debug('start monitoring %s', eventType);
  if (!cb) {
    cb = pid;
    pid = undefined;
  }
  var monitor = (function(pid, eventType, cb) {
    return function monitorCallback(event) {
      if (event.port === eventType) {
        if (!pid || event.node.pid === pid) {
          cb(event.out);
        }
      }
    };
  })(pid, eventType, cb);
  this[how]('output', monitor);
};

/**
 *
 * Handles the output of every node.
 *
 * If there is chi it will be passed along.
 *
 * @param {Object} dat
 * @private
 */

/*
 *  source.id
 *  source.port
 *  action should be in the source?
 *
 *  action is target information, but is the only setting used..
 *  so just have the third parameter be action for now.
 *
 *  source is the full source node.
 **/
//  this.receive(dat.node, dat.port, dat.out, dat.action);
IoMapHandler.prototype.receive = function(source, port, p, action) {
  var i;
  // If the output of this node has any target nodes
  if (this.targetMap.hasOwnProperty(source.pid)) {
    // If there are any target nodes defined
    if (this.targetMap[source.pid].length) {
      // Iterate those targets
      for (i = 0; i < this.targetMap[source.pid].length; i++) {
        // Process this link
        var xlink = this.targetMap[source.pid][i];
        // If the link is about this source port
        if (port === xlink.source.port) {
          // did this output came from an action
          // if so, is it an action we are listening for.
          if (!action || xlink.source.action === action) {
            if (xlink.source.get('collect')) {
              debug('%s: collecting packets', xlink.ioid);
              this.CHI.collect(xlink, p);
              continue; // will be handled by event
            }
            //var noQueue = xlink.target.has('noqueue');
            var noQueue = false;
            this.emit('send', xlink);
            // queue must always be used otherwise persist
            // will not work..
            if (noQueue) {
              // must be sure, really no queue, also not after input.
              this.send(xlink, p);
            }
            else {
              debug('%s: queueing', xlink.ioid);
              this.queueManager.queue(xlink.ioid, p);
            }
          }
        }
      }
    }
  }
};

// collected is about the link
// a group is collected for that link
// and is thus always an array.
// this means the target should be used to re-send
// the collected input.
// the group information is actually not interesting.
// we only know we want the data from the last group.
// and use it.
IoMapHandler.prototype.collected = function( /*target, p*/ ) {
  /*
  data.data
  data.link
  */
};

IoMapHandler.prototype.beginGroup = function( /*group*/ ) {};
IoMapHandler.prototype.sendGroup = function( /*group, data*/ ) {
  /*
  data.data
  data.link
  */
};

/**
 *
 * Add Queue Manager.
 *
 * @param {QueueManager} qm
 * @api private
 *
 */
IoMapHandler.prototype.addQueueManager = function(qm) {
  this.queueManager = qm;
};

IoMapHandler.prototype.getSyncedTargetPorts = function(target) {
  var originId = target.get('sync');
  if (!this.syncedTargetMap.hasOwnProperty(target.pid)) {
    throw new Error(util.format('Unkown sync: `%s`', target.pid));
  }
  if (!this.syncedTargetMap[target.pid].hasOwnProperty(originId)) {
    throw new Error(util.format('Unkown sync with: `%s`', originId));
  }
  // returns the ports array, those who wanna sync with originId
  return this.syncedTargetMap[target.pid][originId];
};

IoMapHandler.prototype.getPointerPorts = function(originId) {
  if (this.pointerPorts.hasOwnProperty(originId)) {
    return this.pointerPorts[originId];
  }
  else {
    throw new Error(util.format('%s has no pointer ports', originId));
  }
};

/**
 *
 * Send synchronized input
 *
 * TODO: Input is synced here then we
 *   throw it into the input sender.
 *   They probably stay synced, but
 *   it's not enforced anywhere after this.
 *
 * @param {string} targetId
 * @param {object} data
 */
IoMapHandler.prototype.sendSynced = function(targetId, data) {
  for (var targetPort in data) {
    if (data.hasOwnProperty(targetPort)) {
      var synced = data[targetPort];
      // opens all queues, a it radical..
      this.queueManager.flushAll();
      // keep in sync, do not use setImmediate
      debug('%s: sendSynced', synced.link.ioid);
      this.__sendData(synced.link, synced.p);
    }
  }
};

IoMapHandler.prototype.drop = function(packet, origin) {
  // TODO: drop data/packet gracefully
  debug('IoMapHandler: Dropping packet %s %s', packet, origin);
  this.emit('drop', packet);
};

module.exports = IoMapHandler;
