'use strict';

var Port = require('../port');
var util = require('util');

var portFill;

module.exports = portFill = exports;

exports.fill = function(ports, input, context) {

  var ret;

  for (var port in ports) {
    if (ports.hasOwnProperty(port)) {
      ret = portFill.defaulter(
        port,
        ports,
        input,
        context
      );
      if (util.isError(ret)) {
        return ret;
      }
    }
  }

  return true;

};

exports.check = function(obj, key, input, context, persist) {
  var ret;

  if (obj[key].properties) { //
    var init;

    if (!input[key]) {
      input[key] = {};
      init = true;
    }

    for (var k in obj[key].properties) {
      if (obj[key].properties.hasOwnProperty(k)) {

        ret = !portFill.check(
          obj[key].properties,
          k,
          input[key],
          context ? context[key] : {},
          persist ? persist[key] : {}
        );

        if (!ret) {

          // use this again, just return the value
          // this will have checked the nested schema definitions.
          // return ret;
          /*
                  throw new Error([
                    this.identifier + ': Cannot determine input for property:',
                    key + '[' + k + ']'
                  ].join(' '));
          */
        }
      }
    }

    if (!Object.keys(input[key]).length && init) {
      // remove empty object again
      delete input[key]; // er ref will not work probably.
    }

    // not sure, but at least should be true.
    return Port.FILLED;

  }
  else {

    // check whether input was defined for this port
    if (!input.hasOwnProperty(key)) {
      // if there is context, use that.
      if (context && context.hasOwnProperty(key)) {
        input[key] = context[key];
        return Port.CONTEXT_SET;
        // check the existance of default (a value of null is also valid)
      }
      else if (persist && persist.hasOwnProperty(key)) {
        input[key] = persist[key];
        return Port.PERSISTED_SET;
      }
      else if (obj[key].hasOwnProperty('default')) {
        input[key] = obj[key].default;
        return Port.DEFAULT_SET;
      }
      else if (obj[key].required === false) {
        // filled but empty let the node handle it.
        input[key] = null;
        return Port.NOT_REQUIRED;
      }
      else {
        return Port.NOT_FILLED;
      }

    }
    else {
      return Port.FILLED;
    }

  }
};

// also fill the defaults one level deep..
/**
 *
 * @param {string} port
 * @private
 */
exports.defaulter = function(port, ports, input, context) {
  if (!portFill.check(
      ports,
      port,
      input,
      context
    ) && !ports[port].async) {

    if (port[0] !== ':') {
      return Port.SYNC_PORTS_UNFULFILLED;
      /*
            // fail hard
            return Error(util.format(
              '%s: Cannot determine input for port `%s`',
              this.identifier,
              port
            ));
      */

    }

  }
};
