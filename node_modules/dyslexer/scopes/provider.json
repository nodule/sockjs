{
  "onLineStart": {
   "tokensExpected": 4
  },

  "validate": {
    "PROVIDER_NS": "/^[A-z_]+$/",
    "AS": "/^as$/i",
    "PROVIDER_URL": "/[A-z0-9:\-\/{}\.#]+/"
  },

  // Used by the lexer to validate token combinations.
  "structure": [
    ["PROVIDER", "PROVIDER_URL"],
    ["PROVIDER", "PROVIDER_URL","AS","PROVIDER_NS"]
  ],

  // Ok, this has to do with the weird jump based on tokensExpected
  // if structure is matched, it means end of scope.
  // which basically means all the below logic is not needed.
  // because it's already automatically detected.
  // tokensExpected is not more than the length of the longest token.
  // also if tokens start getting out of sync there already can be an error.
  // This scope is therefor already fully describeable in json.
  //
  // It's how basic scopes should work. note the validate also.
  //
  // Hmz, the token is PROVIDER is not well defined.
  // basically the whole onToken is not needed here.
  // If validation above matches, it means that's the token.
  // So all that is needed is PROVIDER is added to validate.
  //
  "onToken": {

    if(this.tokens.length === 0) {
      this.lexer.present('PROVIDER', token);
    } else  if(this.tokens.length === 1) {
      this.lexer.present('PROVIDER_URL', token);
    } else if(this.tokens.length === 2) {
      this.lexer.present('AS', token);
    } else if(this.tokens.length === 3) {
      this.lexer.present('PROVIDER_NS', token);
    }

  }

}
