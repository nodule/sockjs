@startuml

Dyslexer -> Scope: onLineStart()
loop next()

  Dyslexer -> Dyslexer: getChar()
  alt character matches rule
    Dyslexer -> Scope: [rule]()
    note right of Scope
      What happens within scope should be structured
      Right now it is free form
    end note
   end

   alt char matches token ending of current scope
      Dyslexer -> Dyslexer: buildToken 
      Dyslexer -> Dyslexer: fireToken
    else Not token ending, not end of line
      Dyslexer -> Dyslexer: buildToken 
    else Scope does not have a token ending but default token ending matches
      Dyslexer -> Dyslexer: fireToken
      
   end

   alt Scope did not define own token ending and we are at the eol
      Dyslexer -> Dyslexer: fireToken (Last one)
      Dyslexer -> Scope:onLineEnd()
      Dyslexer -> Dyslexer: emit('lineTokens')
      note right of Scope
        Bug over here, lineTokens are within the loop 
        This goes correct incedently because tokens are cleared
      end note
      Dyslexer -> Scope:onLineStart()

   end

end

Dyslexer -> Dyslexer: hasToken()
Dyslexer -> Scope: Tokens expected must be set
Dyslexer -> Scope: Number of tokens must be at least expected length

alt scope has a token ending OR root scope rootscope failed to deliver a token.
  alt if this is not the rootScope
   Dyslexer -> Scope:onToken()
  end

end 

legend right

What happens during the rule execution should be structured.
In general it does a scope switch, but it does so conditionally
This condition at the moment is free form, this is too flexible.

Also right now in some scopes there happens way too much within
onToken() basically onToken it tries to find out what the token 
is, it does this based on the current state of the scope but also
the current state of the lexer.

Several patterns can probably be recognized in determining what kind of token it is.

   onToken:
 - does the token validate one of the definitions?
 - token position within the scope (2th etc.)
 - former scope (not used)

I want to have an easy to define JSON file for scopes.
This also means they cannot contain any logic. 
The only logic will be regular expressions

endlegend


@enduml