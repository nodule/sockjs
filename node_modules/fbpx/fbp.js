'use strict';

var DysLexer = require('dyslexer');
var fs = require('fs');
var path = require('path');
var LeftHandScope = require('./scopes/left');
var RightHandScope = require('./scopes/right');
var DataScope = require('./scopes/data');
var CommentScope = require('./scopes/comment');
var ProviderScope = require('./scopes/provider');
var MetaScope = require('./scopes/meta');
var JSONScope = require('./scopes/JSON');
var ActionScope = require('./scopes/Action');
var FunctionScope = require('./scopes/Function');
var FBPDocScope = require('./scopes/FBPDoc');
var RootScope = require('./scopes/root');
var MaskScope = require('./scopes/mask');

/**
 *
 * The FBPParser parses an FBP language file or string and
 * returns a JSON object representing the graph.
 *
 * Currently it supports generating json compatible with noflo & chix.
 *
 *
 * @example Example usage:
 *
 * var renderer = require('fbpx/lib/renderer/chix');
 * var parser = require('fbpx')();
 *
 * parser.addRenderer(renderer);
 * parser.parse(fbp_string);
 *
 * @returns {FBPParser}
 */

var FBPParser = function() {

  if (!(this instanceof FBPParser)) {
    return new FBPParser();
  }

  this.debug = false;
  this.autoReset = true;

  this.lexer = undefined;

  this.currentLink = {};
  this.data = undefined;
  this.include_path = undefined;
  this.renderer = undefined;

  this._nodes = [];

  this.lexerSetup();

};

/**
 *
 * Reset this Parser instance
 *
 * @private
 */
FBPParser.prototype.reset = function() {
  this.currentLink = {};
  this.data = undefined;
  this._nodes = [];
  this.lexer.reset();
};

/**
 *
 * Setup the lexer
 *
 * @private
 */
FBPParser.prototype.lexerSetup = function() {

  this.lexer = new DysLexer('RootScope');
  this.lexer.addScope(LeftHandScope);
  this.lexer.addScope(CommentScope);
  this.lexer.addScope(RootScope);
  this.lexer.addScope(DataScope);
  this.lexer.addScope(JSONScope);
  this.lexer.addScope(FunctionScope);
  this.lexer.addScope(FBPDocScope);
  this.lexer.addScope(MetaScope);
  this.lexer.addScope(ActionScope);
  this.lexer.addScope(ProviderScope);
  this.lexer.addScope(RightHandScope);
  this.lexer.addScope(MaskScope);

  // not done by default.
  // TODO: pass this test always..
  // Requires opening and close tokens also to be fired.
  // now they are swallowed, causing a mismatch.
  // e.g () and {} do not appear as tokens.
  if (this.debug === true) {

    this.lexer.on('lineTokens', function(tokens, line) {

      // check if line matches joined tokens
      var a = [];
      tokens.forEach(function(t) {
        a.push(t.value);
      });
      var sline   = line.replace(/\n/,'').replace(/[\s]+/g, ' ').trim();
      var stokens = a.join(' ')
       .replace(/\s+$/, '')
       .replace(/[\s]+/g, ' ');
      if (sline !== stokens) {
        throw new Error([
          '\n',
          'Mismatch:',
          '>' + sline + '<',
          '>' + stokens + '<'
        ].join('\n'));
      }
    });

  }

};

/**
 *
 * Parse Process
 *
 * @param {type} proc
 * @param {type} in_port
 * @param {type} context
 * @returns {FBPParser.prototype.parseProcess.p}
 */

FBPParser.prototype.parseProcess = function(proc, in_port, context) {

  // first filter out action ::my_action

  // TODO: simplify to not use regexp (saver)
  var c = {},
    ret = proc.match(/^([\w_:]+)\(?([\w-\/:]+)?\)?/);

  var p = {};
  p.name  = ret[1];

  var component = ret[2];

  // test whether processName contains an ::action
  var sp = p.name.split('::');
  if (sp.length > 1 ) {
    p.name        = sp[0];
    p.action      = sp[1];
  }

  if (component && component !== '') {

    c = this.renderer.parseComponentString(component, c);
    c.process = p.name;

    if (this._nodes.indexOf(p.name) === -1) {
      // register node
      //this.renderer.addNode(c, metadata);
      this.renderer.addNode(c);
      this._nodes.push(c.process);
    }

  }

  // maybe also notify if node is refered to.
  this.renderer.touchNode(p.name);

  // context provided
  if (in_port) {
    this.renderer.addContext(p.name, in_port, context);
  }

  return p;

};

FBPParser.prototype.addRenderer = function(renderer) {
  this.renderer = renderer;
};

// remove outer quotes
var quoteReg = new RegExp('^[\'"]|[\'"]$', 'gm');

FBPParser.prototype.handleTokens = function(tokens) {

  var in_port, out_port, process, token, i, ex, spl, collect,
    meta_name, cyclic, persist, context, targetIndex = null, sourceIndex = null,
    export_in, export_out;

  this.currentLink = {};

  this.provider = {};

  for (i = 0; i < tokens.length; i++) {
    token = tokens[i];

    switch(token.name) {

      case 'DATA':
        // TODO: not sure whether to do this replacement here
        // or just send the quoted data.
        this.data = typeof token.value === 'string' ?
          token.value.replace(quoteReg, '') :
          token.value;
        break;
      case 'ACTION':
        this.renderer.actionStart(token.value);
        break;

      // case 'ACTION_START': not used.
      case 'ACTION_END':
        // ends the current action
        this.renderer.actionEnd();
        break;

      case 'FBPDOC':
        // NOP
        break;

      case 'IN_PORT':
        token.value = token.value;

        if (token.value[0] === '^') {
          persist = true;
          token.value = token.value.replace(/^\^/, '');
        }

        if (token.value[0] === '@') {
          // maybe use this for context instead
          token.value = token.value.replace(/^@/, '');
          context = true;
        }

        in_port = token.value;

        break;

      case 'OUT_PORT':
        out_port = token.value;
        break;

      case 'TARGET_INDEX':

        // can now be string or number
        // if is numeric do parseInt else not.
        targetIndex = token.value.replace(/\[|\]/g, '');
        if (/^\d+$/.test(targetIndex)) {
          targetIndex = parseInt(targetIndex);
        }

        break;

      case 'SOURCE_INDEX':

        // can now be string or number
        // if is numeric do parseInt else not.
        sourceIndex = token.value.replace(/\[|\]/g, '');
        if (/^\d+$/.test(sourceIndex)) {
          sourceIndex = parseInt(sourceIndex);
        }

        break;

      case 'AS':
        break;

      case 'PROVIDER_URL':
        if (token.value.indexOf('://') === -1) {
          this.provider.path = token.value;
        } else {
          // else consider it a local file path.
          this.provider.url = token.value;
        }
        break;

      case 'PROVIDER_NS':
        this.provider.name = token.value.toLowerCase();
        break;

      case 'META':
        meta_name = token.value.replace(/:$/, '');
        break;
        
      case 'MASK':
        this.renderer.addMask(token.value);
        break;

      case 'META_DATA':
        this.renderer.addMeta(meta_name, token.value);
        break;

      case 'PROCESS':

        this.currentLink = {};

        if (export_in) {

          process = this.parseProcess(token.value);

          ex = {
            process: process.name,
            port: in_port
          };

          // NOT sure, maybe this needs action also..
          // neh.. It would mean exporting a port from
          // a subgraph which has actions defined.
          // any just add it.
          if (process.action) {
            ex.action = process.action;
          }

          // check for in:title
          // Must be the last one, :start:Start should also work
          // An edge case, I do not really like the disambigity but
          // ah well..
          /*
            ":start:Start".split(':')  ["", "start", "Start"]
            ":start".split(':')        ["", "start"]
            "start".split(':')         ["start"]
            "normal".split(':')        ["normal"]
            "normal:Normal".split(':') ["normal", "Normal"]
          */
          spl = in_port.split(':');
          if (spl.length === 2) {
            ex.port = spl[0];
            ex.name = spl[1];  // alternate portname
          } else if (spl.length === 3) {
            ex.port = ':' + spl[1];
            ex.name = spl[2];  // alternate portname
          } else if (spl.length > 3) {
            throw new Error('Cannot determine port name');
          }

          // this _is_ used in case of exported ports
          if (targetIndex !== null) {
            ex.targetIndex = targetIndex;
          }
          targetIndex = null;

          if (sourceIndex !== null) {
            ex.sourceIndex = sourceIndex;
          }
          sourceIndex = null;

          if (persist) {
            if (!ex.setting) ex.setting = {};
            ex.setting.persist = true;
            persist = undefined;
          }

          this.renderer.addExport(ex, 'input');

          export_in = false;
          in_port = undefined;

        } else if (export_out) {

          process = this.parseProcess(token.value);

          ex = {
            process: process.name,
            port: in_port
          };

          // check for in:title
          spl = in_port.split(':');
          if (spl.length > 1) {
            ex.name = spl[1];  // alternate portname
            ex.port = spl[0];
          }

          // this _is_ used in case of exported ports
          if (targetIndex !== null) {
            ex.targetIndex = targetIndex;
          }
          targetIndex = null;

          if (sourceIndex !== null) {
            ex.sourceIndex = sourceIndex;
          }
          sourceIndex = null;

          // addExport
          // name is title..
          // this also uses inport, because the format is:
          //
          // <- outport Process
          this.renderer.addExport(ex, 'output');

          in_port = undefined;
          export_out = false;

        } else if (context) {

          // this data is now the context
          process = this.parseProcess(token.value, in_port, this.data);

          this.data = undefined;
          context = false;

        } else if (in_port) {

          this.currentLink.in = in_port;

          if (process) {
            this.currentLink.source = process.name;
            if (process.action) {
              this.currentLink.sourceAction = process.action;
            }
          }

          process = this.parseProcess(token.value);
          this.currentLink.target = process.name;
          if (process.action) {
            this.currentLink.targetAction = process.action;
          }

          if (out_port) {
            this.currentLink.out = out_port;
          }

          if (cyclic) {
            if (!this.currentLink.settings) this.currentLink.settings = {};
            this.currentLink.settings.cyclic = true;
          }

          // TODO: a collect cannot be exported (doesn't really matter now)
          if (collect) {
            if (!this.currentLink.settings) this.currentLink.settings = {};
            this.currentLink.settings.collect = true;
          }

          if (persist) {
            if (!this.currentLink.settings) this.currentLink.settings = {};
            this.currentLink.settings.persist = true;
          }

          if (this.data !== undefined) {
            this.currentLink.data = this.data;
            this.data = undefined;
          }

          if (targetIndex !== null) {
            // can now be string or number
            // if is numeric do parseInt else not.
            this.currentLink.targetIndex = targetIndex;
          }
          targetIndex = null;

          if (sourceIndex !== null) {
            // can now be string or number
            // if is numeric do parseInt else not.
            this.currentLink.sourceIndex = sourceIndex;
          }
          sourceIndex = null;

          this.renderer.addLink(this.currentLink);

          this.currentLink = {};
          cyclic  = false;
          persist = false;
          collect = false;

        } else {
          // first, just register the process
          process = this.parseProcess(token.value);
        }

        break;

      case 'COMMENT':
        // ignore comments
        break;

      case 'EXPORT':

        var match = token.value.match(/^\s*EXPORT=(.*)/);

        var e  = match[1].split(':'),
          pp = e[0].split('.');

        var da = {
          name: e[1], // a different name for the port
          process: pp[0],
          port: pp[1].toLowerCase()
        };

        this.renderer.addExport(da, 'input');

        break;

      // will change the way how right hand scope
      // is handled, a bit like DATA is handled.
      case 'EXPORT_IN':
        export_in = true;
        break;
      case 'EXPORT_OUT':
        export_out = true;
        break;
      case 'COLLECT_ARROW':
        collect = true;
        break;
      case 'INCLUDE_ARROW':
        // we already have data now, so overwrite that with
        // whatever we fetch localy or remote
        if (!this.data) {
          throw new Error('Cannot include without data section');
        }
        this.data = this.include(this.data);
        break;
      //case 'ARROW':
      case 'PAIRED_ARROW':
        if (token.value === '=>' ||
           token.value === '⇉') {
          cyclic = true;
        }
        break;
    }

  }

  if (Object.keys(this.provider).length) {
    this.renderer.addProvider(this.provider);
  }

};

/**
 *
 * Data Include
 *
 * Used to process `~>`
 *
 * Will treat the input as a file and tries to include it's contents
 *
 * @example Data include
 * 'my_json_file' ~> in MyProcess
 *
 * @param {Object} data
 * @returns {String}
 */

FBPParser.prototype.include = function(data) {

  var body;
  var res = data.split('!');
  var file = res[0];
  var type = res[1];
  if (!this.include_path) this.include_path = process.cwd();
  body = fs.readFileSync(path.resolve(this.include_path, file)).toString();
  if (undefined !== type) {
    if (type === '' || type === 'json') {
      return JSON.parse(body);
    } else {
      return body;
    }
  } else {
    return body;
  }

};

/*
  if (isUrl(data) || typeof window !== 'undefined') {
    // full url or relative client side path
    request.get(data, function(err, res) {

      if (err) throw new Error(err);

      cb(null, res.text);

    });
  } else {

    return fs.readFile(path.resolve(this.include_path, data), function(err, data) {

      if (err) throw new Error(err);

      cb(null, data.toString());

    });
*/

/**
 *
 * Parse File
 *
 * @param {String} file
 * @returns {Object}
 *
 */

FBPParser.prototype.parseFile = function(file) {

  // this is used to resolve data includes
  this.include_path = path.dirname(file);

  return this.parse(fs.readFileSync(file, 'utf-8'));

};

/**
 *
 * Get IIPs
 *
 * Returns the collected IIPs
 *
 * To store initial data within the JSON itself context should be used.
 * @returns {Object}
 */
FBPParser.prototype.getIIPs = function() {
  return this.renderer.getIIPs();
};

/**
 * Parses an FBP string.
 * @param {String} str An fbp language string
 * @param {string} include_path Hint for data includes
 * @returns {Object}
 */
FBPParser.prototype.parse = function(str, include_path) {

  if (include_path) {
    this.include_path = include_path;
  }

  if (this.autoReset) {
    this.reset();
    this.renderer.reset();
  }

  if (!this.renderer) {
    throw new Error('FBPParser needs a renderer');
  }

  var tokens = this.lexer.start(str, true);
  for (var i = 0; i < tokens.length; i++) {
    this.handleTokens(tokens[i]);
  }

  return this.renderer.getFlow();

};

module.exports = FBPParser;
