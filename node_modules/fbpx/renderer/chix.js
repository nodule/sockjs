'use strict';

var uuid = require('uuid');
var xLink = require('chix-flow').Link;

var Renderer = function(options) {

  options = options || {};

  if (!(this instanceof Renderer)) {
    return new Renderer(options);
  }

  // do not set uuids
  this.skipIDs = options.skipIDs || false;

  this.mask = undefined;

  if (options.defaultProvider === false) {
    this.defaultProvider = false;
  } else if (options.defaultProvider) {
    this.setDefaultProvider(options.defaultProvider);
  } else {
    this.setDefaultProvider('https://serve-chix.rhcloud.com/nodes/{ns}/{name}');
  }

  this.reset();

};

Renderer.prototype.actionStart = function(name) {

  // e.g. ::Delete
  this.action = name.replace('::', '');

  if (!this.flow.actions) {
    this.flow.actions = {};
  }

  this.flow.actions[this.action] = {
    title: this.action,
    nodes: []
  };

};

Renderer.prototype.actionEnd = function() {
  // e.g. ::Delete
  this.action = undefined;
};

Renderer.prototype.setDefaultProvider = function(url) {

  this.defaultProvider = {
    url: url
  };

};

/**
 *
 * Called from the fbpParser
 *
 */
Renderer.prototype.parseComponentString = function(component, node) {

  // check for meta data
  var m = component.split(':');

  // Now: NS:ns/name or ns/name
  if (m.length === 1) {
    node.component = component;
  } else {
    node.component = m.pop();
    node.NS = m.pop();
  }

  return node;

};

Renderer.prototype.reset = function() {

  this.flow = {};
  if (!this.skipIDs) {
    this.flow.id = uuid.v4();
  }
  this.flow.type = 'flow',
  this.flow.nodes = [];
  this.flow.links = [];

  // simplify node finding used by input.
  this.nodes = {};

  // simplify index finding.
  this.idx = [];

  this.iips = [];

  // this.exports = undefined;

  this.knownNodes = [];

  this.nameToUuid = {};

};

Renderer.prototype.addNode = function(c) {

  var ns;
  var name;

  var m = c.component.split('/');
  if (m.length !== 2) {
    name = c.component;
  } else {
    ns = m[0];
    name = m[1];
  }

  var uuid = this.getUUID(c.process);

  var node = {
    id: uuid,
    title: c.process,
    ns: ns,
    name: name
  };

  // Big namespace, the provider url
  if (c.NS) node.provider = c.NS;

  // fix this also, must use uuid.
  //var lprocess = c.process.toLowerCase();
  var lprocess = this.getUUID(c.process);
  if (this.exports && this.exports[lprocess]) {
    node.ports = this.exports[lprocess];
  }

/*
  if (metadata) {
    this.flow.processes[c.process].metadata = {
      routes: metadata
    };
  }
*/

  this.nodes[node.id] = node;

  if (this.skipIDs) node.id = node.title;

  this.flow.nodes.push(node);

  this.idx.push(uuid);

};

// a node is mentioned
Renderer.prototype.touchNode = function(processName) {

  var uuid = this.getUUID(processName);

  // register it
  if (this.action) {
    var aNodes = this.flow.actions[this.action].nodes;
    if (aNodes.indexOf(uuid) === -1) {
      // ok problem if the node is just referenced.
      aNodes.push(uuid);
    }
  }

};

// FIX ME (or not): It can happen a node is not defined yet
Renderer.prototype.addContext = function(process, inPort, context) {
  var uuid = this.getUUID(process);
  var node = this.flow.nodes[this.idx.indexOf(uuid)];
  if (!node) {
    throw Error([
      'Node',
      process,
      'is not defined'
    ].join(' '));
  }
  if (!node.context) node.context = {};
  node.context[inPort] = context;
};

Renderer.prototype.addLink = function(link) {

  var newLink = this.skipIDs ? xLink.create(false) : xLink.create();

  var targetId = this.getUUID(link.target);

  // in[MyProcess]
  var sync = link.in.match(/\[(.*)\]/);
  if (sync) {
    link.in   = link.in.replace(sync[0], '');
  }

  newLink.setTarget(targetId, link.in);
  newLink.target.set('index', link.targetIndex);
  newLink.target.set('sync', link.sync);

  if (link.targetAction) {
    // hm, put action within setting or not? neh;
    newLink.target.action = link.targetAction;
  }

  if (sync) {
    // MyProcess
    newLink.target.set('sync', this.getUUID(sync[1]));
  }

  // TODO: link.settings is no more..
  if (link.hasOwnProperty('settings')) {
    if (link.settings.cyclic) {
      newLink.target.set('cyclic', true);
    }
    if (link.settings.persist) {
      newLink.target.set('persist', true);
    }
  }

  if (this.mask !== undefined) {
    newLink.target.set('mask', this.mask);
    this.mask = undefined; // reset
  }

  var pointer = false;

  // Ok, right now I do not save data within the link.
  if (!link.source) {

    // iip.
    link.source = this.flow.title || '';
    link.out    = ':iip';
    newLink.setSource(this.flow.id, link.out);

  } else {
    if (link.out.charAt(0) === '*') {
      link.out = link.out.slice(1);
      pointer = true;
    }
    newLink.setSource(this.getUUID(link.source), link.out);
  }

  if (link.sourceAction) {
    // hm, put action within setting or not? neh;
    newLink.source.action = link.sourceAction;
  }

  if (pointer) {
    newLink.source.set('pointer', true);
  }

  if (link.hasOwnProperty('settings')) {
    if (link.settings.collect) {
      newLink.source.set('collect', true);
    }
  }

  if (this.skipIDs) delete newLink.id;
  if (link.sourceIndex !== undefined) {
    newLink.source.set('index', link.sourceIndex);
  }

  // Not really important this..
  newLink.setTitle([
      link.source + (link.sourceAction ? '::' + link.sourceAction : ''),
      link.out,
      '->',
      link.in,
      link.target + (link.targetAction ? '::' + link.targetAction : ''),
    ].join(' ')
  );

  if (newLink.source.port === ':iip') {

    // note: this is different from specifying an action within target
    // or source.
    //
    // within target it means target the action of the node I'm pointing to.
    //
    // This however indicates the iip must run during this action.
    // TODO: above not valid anymore
    if (this.action) {
      newLink.action = this.action;
    }

    newLink.data = link.data;

    this.iips.push(newLink.toJSON());

  } else {

    this.flow.links.push(newLink.toJSON());

  }

};

Renderer.prototype.addProvider = function(provider) {

  if (!this.flow.providers)  this.flow.providers = {};
  var key = provider.name ? provider.name : '@';
  this.flow.providers[key] = provider;
};

Renderer.prototype.addMeta = function(name, value) {

  if (this.action) {
    this.flow.actions[this.action][name] = value;
  } else {

    if (name === 'package') {
      // TODO: I want ns to be pkg
      // but this will be a lot of renaming..
      this.flow['ns'] = value;
    } else {
      this.flow[name] = value;
    }

  }
};

Renderer.prototype.addExport = function(c, ioType) {

  var lprocess;

  //lprocess = c.process.toLowerCase();
  lprocess = this.getUUID(c.process);

  // ok, this only handles exposed input ports.
  // port def will be empty, but this doesn't matter.
  // the real information is in the node.
  // we could use it to override title though.
  if (!this.flow.ports) this.flow.ports = {};

  if (!this.flow.ports.hasOwnProperty(ioType)) {
    this.flow.ports[ioType] = {};
  }

  if (!c.port) {
    if (c.name) {
      // -> :start Proc (: is used to defined title normally)
      c.port = c.name;
      delete c.name;
    } else {
      throw new Error([
        'No port defined to expose for',
        c.name
      ].join(' ')
      );
    }

  }

  var portName = this.determineExternalPortName(c.port, c.name, ioType);
  this.flow.ports[ioType][portName] = {
    nodeId: lprocess,
    //title: c.process + ' ' + c.port, // default title
    title: portName.charAt(0).toUpperCase() + portName.slice(1),
    name: c.port
  };

  // this _is_ used with exported ports.
  // because the external port will not require you to set an index
  // the internal port however needs to pass on this information.
  if (ioType === 'input' && c.hasOwnProperty('targetIndex')) {

    // should be within setting.index
    if (!this.flow.ports.input[portName].setting) {
      this.flow.ports.input[portName].setting = {};
    }

    this.flow.ports['input'][portName].setting.index = c.targetIndex;

  } else if (ioType === 'output' && c.hasOwnProperty('sourceIndex')) {

    if (!this.flow.ports.output[portName].setting) {
      this.flow.ports.output[portName].setting = {};
    }

    this.flow.ports['output'][portName].setting.index = c.sourceIndex;

  }

  if (c.setting) {
    if (!this.flow.ports.input[portName].setting) {
      this.flow.ports.input[portName].setting = {};
    }
    for (var k in c.setting) {
      if (c.setting.hasOwnProperty(k)) {
        this.flow.ports.input[portName].setting[k] = c.setting[k];
      }
    }
  }

  // BELOW I WANT TO DROP, expose will be different.
  // see above
  // Let's assume exports are defined before node declaration
  if (!this.exports) {
    this.exports = {};
  }

  if (!this.exports[lprocess]) {
    this.exports[lprocess] = {
      input: {}
    };
  }

  this.exports[lprocess].input[c.port] = {
    // not sure what to do with the alias,
    // also could override name here.
    title: c.name,
    expose: true
  };

};

/**
 *
 * Get the IIPs
 *
 * The idea is not to include them in the graph definition.
 *
 * But allow them to be send to the created graph.
 *
 */
Renderer.prototype.getIIPs = function(action) {

  if (action) {

    var iips = this.iips.filter(function(el) {
      return el.action === action;
    });

    return iips;

  } else {
    return JSON.parse(JSON.stringify(this.iips));
  }

};

/**
 *
 * Get the Input
 *
 * Returns an object containing all data input.
 *
 * It is not used for processing, but it can
 * be used for display purposes.
 *
 */
Renderer.prototype.getInput = function() {
  var results = [];
  var nodeId;

  for (nodeId in this.iips) {

    if (this.iips.hasOwnProperty(nodeId)) {

      var iip = this.iips[nodeId];
      var result = iip.target;

      if (this.nodes[iip.target.id]) {

        // todo: weird construction
        result.process  = this.nodes[iip.target.id].title;

        if (iip.data === undefined) {
          throw Error('IIP data may not be `undefined`');
        }

        result.data     = iip.data;
        result.target   = iip.target;
        // todo: is now target.settings && source.settings.
        result.settings = iip.settings;
        if (iip.action) {
          // dunno, could be in settings also.
          result.action = iip.action;
        }
        results.push(result);

      } else {
        throw new Error(
          'IIP refers to unknown node'
        );
      }

    }
  }

  // Fill context
  for (nodeId in this.nodes) {

    if (this.nodes[nodeId].context) {

      for (var port in this.nodes[nodeId].context) {

        if (this.nodes[nodeId].hasOwnProperty(port)) {

          results.push({
            process: this.nodes[nodeId].title,
            port: port,
            data: this.nodes[nodeId].context[port],
            context: true
          });

        }
      }

    }
  }

  return results;
};

Renderer.prototype.getFlow = function() {

  this.ensureDefaultProvider();

  this.checkNodes();

  return JSON.parse(JSON.stringify(this.flow));
};

Renderer.prototype.toJSON = function() {

  // TODO: add logic here to detected unconnected nodes.

  if (this.skipIDs) delete this.flow.id;

  this.checkNodes();

  return JSON.stringify(this.flow, null, 2);

};

// Because we generate ID's on the fly and before
// we know process names, (because links can come before definition)
// We have to check whether all links point to existing nodes.
Renderer.prototype.checkNodes = function() {

  for (var name in this.nameToUuid) {

    if (
      this.nameToUuid.hasOwnProperty(name) &&
      !this.nodes.hasOwnProperty(this.nameToUuid[name])
      ) {

      console.log(this.nodes);
      throw new Error([
        'Node',
        name,
        'is not defined'
      ].join(' '));
    }
  }

};

Renderer.prototype.getUUID = function(name) {

  if (this.skipIDs) return name;

  if (!this.nameToUuid.hasOwnProperty(name)) {
    this.nameToUuid[name] = uuid.v4();
  }

  return this.nameToUuid[name];

};

/**
 *
 *  Adds a mask, this mask is always about the next
 * link added, the next link added *must* do something
 * with this value
 *
 */
Renderer.prototype.addMask = function(mask) {
  this.mask = mask;
};

Renderer.prototype.getName = function(uuid) {

  if (this.skipIDs) return uuid;

  var id;
  var name;
  var key;

  for (key in this.nameToUuid) {

    if (this.nameToUuid.hasOwnProperty(key)) {
      name = key;
      id = this.nameToUuid[key];
      if (id === uuid) break;
    }
  }

  if (!name) throw new Error('Cannot find name for uuid: ' + uuid);

  return name;

};

/**
 *
 * Makes sure the external portname is unique.
 *
 * TODO: just throw an error when we get an externalName provided and
 * it proofs not to be unique, this is an .fbp syntax error
 *
 */
Renderer.prototype.determineExternalPortName = function(internalName, externalName, ioType) {

  var portName = externalName ? externalName : internalName;
  var origName = portName;

  // ok here is the case of internal (c.port) and external name
  // for the iips I also need this. for now I will not support
  // custom naming of the port, I could though, ah well
  // let's see, so that this needs is internalPort, externalPort
  if (this.flow.ports[ioType].hasOwnProperty(portName)) {
    var nr = 2;
    while (this.flow.ports[ioType].hasOwnProperty(portName)) {
      portName = origName + nr++;
    }
  }

  return portName;

};

Renderer.prototype.fbpdoc = function(params) {
  console.log(params);
};

/**
 *
 * Ensures a default provider is set, but only if nodes are used
 * without a namespace and only set one if there was not yet a
 * default set, within the fbp file.
 *
 */
Renderer.prototype.ensureDefaultProvider = function() {
  if (this.defaultProvider !== false) {
    if (!this.flow.providers)  {
      this.flow.providers = {};
    }
    if (!this.flow.providers.hasOwnProperty('@')) {
      for (var i = 0; i < this.flow.nodes.length; i++) {
        if (!this.flow.nodes[i].hasOwnProperty('provider')) {
          // means there is at least one node depending
          // on a default namespace so create one.
          this.flow.providers['@'] = this.defaultProvider;
          break;
        }
      }
    }
  }
};

module.exports = Renderer;
