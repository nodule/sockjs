'use strict';

var IOBox = require('iobox');
var util = require('util');
var path = require('path');

// taken from underscore.string.js
function _underscored(str) {
  // also underscore dot
  return str
    .replace(/([a-z\d])([A-Z]+)/g, '$1_$2')
    .replace(/[\.\-\s]+/g, '_')
    .toLowerCase();
}

/**
 *
 * NodeBox
 *
 * @constructor
 * @public
 *
 */
function NodeBox(name) {

  if (!(this instanceof NodeBox)) {
    return new NodeBox(name);
  }

  this.args = {};

  // what to return from the function
  this.return = ['output', 'state', 'on'];

  // Define the structure
  this.addArg('input', {});
  this.addArg('output', {});
  this.addArg('state', {});
  this.addArg('done', null);
  this.addArg('cb', null);
  //this.addArg('console', console);

  this.addArg('on', {
    input: {}
  }); // dynamic construction

  this.name = name || 'NodeBox';

}

util.inherits(NodeBox, IOBox);

/**
 *
 * Used to access the properties at the top level,
 * but still be able to get all relevant arguments
 * at once using this.args
 *
 * TODO: just move this to IOBox.
 *
 * @param {String} key
 * @param {Mixed} initial
 */
NodeBox.prototype.addArg = function(key, initial) {

  Object.defineProperty(this, key, {
    set: function(val) {
      this.args[key] = val;
    },
    get: function() {
      return this.args[key];
    }
  });

  if (typeof initial !== 'undefined') {
    this[key] = initial;
  }

};

/**
 *
 * Sets a property of the sandbox.
 * Because the keys determine what arguments will
 * be generated for the function, it is important
 * we keep some kind of control over what is set.
 *
 * @param {String} key
 * @param {Mixed} value
 *
 */
NodeBox.prototype.set = function(key, value) {

  if (this.args.hasOwnProperty(key)) {
    this.args[key] = value;
  }
  else {
    throw new Error([
      'Will not set unknown property',
      key
    ].join(' '));
  }
};

/**
 *
 * Add requires to the sandbox.
 *
 * xNode should use check = true and then have
 * a try catch block.
 *
 * @param {Object} requires
 * @param {Boolean} check
 */
NodeBox.prototype.require = function(requires, check) {

  // Ok, the generic sandbox should do the same logic
  // for adding the requires but should not check if
  // they are available.
  var key;
  var ukey;

  // 'myrequire': '<version'
  for (key in requires) {

    if (requires.hasOwnProperty(key)) {

      // only take last part e.g. chix-flow/SomeThing-> some_thing
      ukey = _underscored(key.split('/').pop());

      this.emit('require', {
        require: key
      });

      if (check !== false) {

        if (typeof requires[key] !== 'string') {

          // assume it's already required.
          // the npm installed versions use this.
          // e.g. nodule-template
          this.args[ukey] = requires[key];

        }
        else {

          try {

            this.args[ukey] = require(key);

          }
          catch (e) {

            // last resort, used by cli
            var p = path.resolve(
              process.cwd(),
              'node_modules',
              key
            );

            this.args[ukey] = require(p);
          }

        }

      }
      else {

        // just register it, used for generate
        this.args[ukey] = undefined;

      }
    }
  }
};

NodeBox.prototype.expose = function(expose, CHI) {

  var i;
  // created to allow window to be exposed to a node.
  // only meant to be used for dom nodes.
  var g = typeof window === 'undefined' ? global : window;

  if (expose) {

    for (i = 0; i < expose.length; i++) {

      this.emit('expose', {
        expose: expose[i]
      });

      if (expose[i] === 'window') {
        this.args.win = window;
      }
      else if (expose[i] === 'chi') {
        this.args.chi = CHI;
      }
      else if (expose[i] === 'self') {
        this.args.self = this;
      }
      else {
        // Do not re-expose anything already going in
        if (!this.args.hasOwnProperty(expose[i])) {
          this.args[expose[i]] = g[expose[i]];
        }
      }
    }

  }
};

NodeBox.prototype.compile = function(fn) {

  return IOBox.prototype.compile.call(
    this, fn, Object.keys(this.args), this.return, true // return as object
  );

};

NodeBox.prototype.fill = function(fn) {

  return IOBox.prototype.fill.call(
    this, fn, Object.keys(this.args), this.return, true // return as object
  );

};

/**
 *
 * Runs the sandbox.
 *
 */
NodeBox.prototype.run = function(bind) {

  var k;
  var res = IOBox.prototype.run.apply(this, [this.args, bind]);
  var ret;

  // puts the result back into our args/state
  for (k in res) {
    if (k === 'return') {
      ret = res['return'];
    }
    else if (res.hasOwnProperty(k)) {
      this.args[k] = res[k];
    }
  }
  return ret; // original return value
};

module.exports = NodeBox;
