'use strict';

var NodeBox = require('./sandbox/node');
var PortBox = require('./sandbox/port');
var CHI = require('chix-chi');
var namify = require('namify');

function createPortBox(def, fn, name) {
  var portbox = new PortBox(name);
  // state is not remembered ?
  portbox.set('state', def.state);
  portbox.set('output', {});
  if (def.dependencies && def.dependencies.npm) {
    portbox.require(def.dependencies.npm, true);
  }
  portbox.expose(def.expose, new CHI());

  fn = fn.slice(
    fn.indexOf('{') + 1,
    fn.lastIndexOf('}')
  );

  portbox.compile(fn);

  return portbox;

}

function fix(str) {
    str = namify(str);
    str = !isNaN(str[0]) ? '_' + str : str;
    return str;

  }
  /**
   *
   * Used to create a non dynamic definition for this node.
   * Having the node & port boxes pre-compiled
   */
module.exports = function(def) {

  var fn = def.fn;
  delete def.fn;

  var nodebox = new NodeBox(fix(def.name));

  var state = {};
  var output = {};

  var input = {};

  if (Object.keys(def.ports.input).length) {
    Object.keys(def.ports.input).forEach(function(key) {
      input[key] = true;
    });
  }

  nodebox.set('input', input);

  // done() is added to the nodebox
  nodebox.set('done', function() {});
  nodebox.set('cb', function() {});
  nodebox.set('state', state);
  if (def.dependencies && def.dependencies.hasOwnProperty('npm')) {
    nodebox.require(def.dependencies.npm);
  }
  if (def.expose) {
    nodebox.expose(def.expose, {});
  }
  nodebox.set('output', output);

  if (/output(\.[A-z]+)?\s+=/.test(fn) &&
    // should not match = function
    /output\s*=\s*function/.test(fn) === false) {

    // array variant
    if (/output\s*=\s*\[/.test(fn)) {

      output = fn
        .replace(/output\s*=/, '')
        .replace(/(\[|\])/g, '')
        .replace(/;/g, '')
        .trim().split(',');

      // type: 'ApiMethod'

      // crazy.
      def.fn = [
        output[0], '.',
        def.name, // could break existing, but then should be fixed.
        //output[1],
        '(',
        output.slice(2).join(','),
        ', function ' + def.name + 'Callback',
        '(', // would like that to be output instead of cb..
        Object.keys(def.ports.output), // must be in order
        ') {',
        'cb({',
        Object.keys(def.ports.output).map(function(k) {
          return k + ': ' + k;
        }).join(', '),
        '});',
        '});'
      ].join('');

      // re-compile
      def.fn = nodebox.compile(def.fn);

    }
    else {
      // Then consider the whole body as our function.
      nodebox.compile(fn);
      // Function(this.name, nodebox.code.replace(/^return /, ''));
      def.fn = nodebox.fn;
    }

  }
  else {

    nodebox.compile(fn);
    nodebox.run();

    // port functions
    // darn. need to construct those.
    Object.keys(def.ports.input).forEach(function(port) {
      if (nodebox.on.input[port]) {
        // should then be created as portbox.
        var pb = createPortBox(
          def,
          nodebox.on.input[port].toString(), ('__' + port + '__').toUpperCase()
        );
        pb.compile();
        def.ports.input[port].fn = pb.fn;
        // State, only necessary when there are async..
        def.state = state;
      }
    });

    // Start/shutdown
    ['start', 'shutdown'].forEach(function(key) {
      if (nodebox.on[key]) {
        // tjah where to put it on.start ?
        if (!def.on) {
          def.on = {};
        }
        var pb = createPortBox(
          def,
          nodebox.on[key].toString(), ('__' + 'on' + key + '__').toUpperCase()
        );
        pb.compile();
        def.on[key] = pb.fn;
      }
    });

    // NodeBox main()
    if (typeof nodebox.output === 'object' && nodebox.output.out) {
      // If it is an object we can just use that as the body.
      def.fn = nodebox.fn;
    }
    else if (typeof nodebox.output === 'function') {
      // could change this to default and not use function at all.
      def.fn = nodebox.output.toString()
        .replace(/function.*{/, '')
        .replace(/}.*$/, '')
        .trim()
        // prefered is now to just use output()
        .replace(/cb\s*\(/g, 'output(');
      nodebox.clear(); // reset
      def.fn = nodebox.compile(def.fn);
    }

  }

  return def;

};
