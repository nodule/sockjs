'use strict';

/* jshint maxlen:420 */

var chai = require('chai');
var NoFloRenderer = require('../renderer/noflo');
var Parser = require('../fbp');

var createParser = function () {
  var parser = new Parser();
  var renderer = new NoFloRenderer();
  parser.addRenderer(renderer);
  return parser;
};

describe('FBP parser', function () {
  it('should provide a parse method', function () {
    var parser = createParser();
    return chai.expect(parser.parse).to.be.a('function');
  });
  describe('with simple FBP string', function () {
    var fbpData, graphData, parser;
    fbpData = '\'somefile\' -> SOURCE Read(ReadFile)\n';
    graphData = null;
    it('should produce a graph JSON object', function () {
      parser = createParser();
      graphData = parser.parse(fbpData);
      return chai.expect(graphData).to.be.an('object');
    });
    return describe('the generated graph', function () {
      it('should contain one node', function () {
        return chai.expect(graphData.processes).to.eql({
          Read: {
            component: 'ReadFile'
          }
        });
      });
      return it('should contain an IIP', function () {
        chai.expect(graphData.connections).to.be.an('array');
        return chai.expect(graphData.connections.length).to.equal(1);
      });
    });
  });
  describe('with three-statement FBP string', function () {
    var fbpData, graphData, parser;
    fbpData = '\'somefile.txt\' -> SOURCE Read(ReadFile) OUT -> IN Display(Output)';
    graphData = null;
    it('should produce a graph JSON object', function () {
      parser = createParser();
      graphData = parser.parse(fbpData);
      return chai.expect(graphData).to.be.an('object');
    });
    return describe('the generated graph', function () {
      it('should contain two nodes', function () {
        return chai.expect(graphData.processes).to.eql({
          Read: {
            component: 'ReadFile'
          },
          Display: {
            component: 'Output'
          }
        });
      });
      it('should contain an edge and an IIP', function () {
        chai.expect(graphData.connections).to.be.an('array');
        return chai.expect(graphData.connections.length).to.equal(2);
      });
      return it('should contain no exports', function () {
        chai.expect(graphData.exports).to.be.an('array');
        return chai.expect(graphData.exports.length).to.equal(0);
      });
    });
  });
  describe('with a more complex FBP string', function () {
    var fbpData, graphData, parser;
    fbpData = '\'8003\' -> LISTEN WebServer(HTTP/Server) REQUEST -> IN Profiler(HTTP/Profiler) OUT -> IN Authentication(HTTP/BasicAuth)\nAuthentication() OUT -> IN GreetUser(HelloController) OUT -> IN WriteResponse(HTTP/WriteResponse) OUT -> IN Send(HTTP/SendResponse)\n\'hello.jade\' -> SOURCE ReadTemplate(ReadFile) OUT -> TEMPLATE Render(Template)\nGreetUser() DATA -> OPTIONS Render() OUT -> STRING WriteResponse()';
    graphData = null;
    it('should produce a graph JSON object', function () {
      parser = createParser();
      graphData = parser.parse(fbpData);
      return chai.expect(graphData).to.be.an('object');
    });
    return describe('the generated graph', function () {
      it('should contain eight nodes', function () {
        chai.expect(graphData.processes).to.be.an('object');
        return chai.expect(graphData.processes).to.have.keys(['WebServer', 'Profiler', 'Authentication', 'GreetUser', 'WriteResponse', 'Send', 'ReadTemplate', 'Render']);
      });
      it('should contain ten edges and IIPs', function () {
        chai.expect(graphData.connections).to.be.an('array');
        return chai.expect(graphData.connections.length).to.equal(10);
      });
      return it('should contain no exports', function () {
        chai.expect(graphData.exports).to.be.an('array');
        return chai.expect(graphData.exports.length).to.equal(0);
      });
    });
  });
  describe('with FBP string containing an IIP with whitespace', function () {
    var fbpData, graphData, parser;
    fbpData = '\'foo Bar BAZ\' -> IN Display(Output)';
    graphData = null;
    it('should produce a graph JSON object', function () {
      parser = createParser();
      graphData = parser.parse(fbpData);
      return chai.expect(graphData).to.be.an('object');
    });
    return describe('the generated graph', function () {
      it('should contain a node', function () {
        return chai.expect(graphData.processes).to.eql({
          Display: {
            component: 'Output'
          }
        });
      });
      it('should contain an IIP', function () {
        chai.expect(graphData.connections).to.be.an('array');
        chai.expect(graphData.connections.length).to.equal(1);
        return chai.expect(graphData.connections[0].data).to.equal('foo Bar BAZ');
      });
      return it('should contain no exports', function () {
        chai.expect(graphData.exports).to.be.an('array');
        return chai.expect(graphData.exports.length).to.equal(0);
      });
    });
  });
  describe('with FBP string containing an empty IIP string', function () {
    var fbpData, graphData, parser;
    fbpData = '\'\' -> IN Display(Output)';
    graphData = null;
    it('should produce a graph JSON object', function () {
      parser = createParser();
      graphData = parser.parse(fbpData);
      return chai.expect(graphData).to.be.an('object');
    });
    return describe('the generated graph', function () {
      it('should contain a node', function () {
        return chai.expect(graphData.processes).to.eql({
          Display: {
            component: 'Output'
          }
        });
      });
      it('should contain an IIP', function () {
        chai.expect(graphData.connections).to.be.an('array');
        chai.expect(graphData.connections.length).to.equal(1);
        return chai.expect(graphData.connections[0].data).to.equal('');
      });
      return it('should contain no exports', function () {
        chai.expect(graphData.exports).to.be.an('array');
        return chai.expect(graphData.exports.length).to.equal(0);
      });
    });
  });
  describe('with FBP string containing comments', function () {
    var fbpData, graphData, parser;
    fbpData = '# Do stuff\n\'foo bar\' -> IN Display(Output) # Here we show the string';
    graphData = null;
    it('should produce a graph JSON object', function () {
      parser = createParser();
      graphData = parser.parse(fbpData);
      return chai.expect(graphData).to.be.an('object');
    });
    return describe('the generated graph', function () {
      it('should contain a node', function () {
        return chai.expect(graphData.processes).to.eql({
          Display: {
            component: 'Output'
          }
        });
      });
      it('should contain an IIP', function () {
        chai.expect(graphData.connections).to.be.an('array');
        chai.expect(graphData.connections.length).to.equal(1);
        return chai.expect(graphData.connections[0].data).to.equal('foo bar');
      });
      return it('should contain no exports', function () {
        chai.expect(graphData.exports).to.be.an('array');
        return chai.expect(graphData.exports.length).to.equal(0);
      });
    });
  });
  describe('with FBP string containing URL as IIP', function () {
    var fbpData, graphData, parser;
    fbpData = '\'http://localhost:5984/default\' -> URL Conn(couchdb/OpenDatabase)';
    graphData = null;
    it('should produce a graph JSON object', function () {
      parser = createParser();
      graphData = parser.parse(fbpData);
      return chai.expect(graphData).to.be.an('object');
    });
    return describe('the generated graph', function () {
      it('should contain a node', function () {
        return chai.expect(graphData.processes).to.eql({
          Conn: {
            component: 'couchdb/OpenDatabase'
          }
        });
      });
      it('should contain an IIP', function () {
        chai.expect(graphData.connections).to.be.an('array');
        chai.expect(graphData.connections.length).to.equal(1);
        return chai.expect(graphData.connections[0].data).to.equal('http://localhost:5984/default');
      });
      return it('should contain no exports', function () {
        chai.expect(graphData.exports).to.be.an('array');
        return chai.expect(graphData.exports.length).to.equal(0);
      });
    });
  });
  describe('with FBP string containing RegExp as IIP', function () {
    var fbpData, graphData, parser;
    fbpData = '\'_id=(\d+\.\d+\.\d*)=http://iks-project.eu/%deliverable/$1\' -> REGEXP MapDeliverableUri(MapPropertyValue)\n\'path=/_(?!(includes|layouts)\' -> REGEXP MapDeliverableUri(MapPropertyValue)\n\'@type=deliverable\' -> PROPERTY SetDeliverableProps(SetProperty)\n\'#foo\' -> SELECTOR Get(dom/GetElement)\n\'Hi, {{ name }}\' -> TEMPLATE Get';
    graphData = null;
    it('should produce a graph JSON object', function () {
      parser = createParser();
      graphData = parser.parse(fbpData);
      return chai.expect(graphData).to.be.an('object');
    });
    return describe('the generated graph', function () {
      it('should contain two nodes', function () {
        return chai.expect(graphData.processes).to.eql({
          MapDeliverableUri: {
            component: 'MapPropertyValue'
          },
          SetDeliverableProps: {
            component: 'SetProperty'
          },
          Get: {
            component: 'dom/GetElement'
          }
        });
      });
      it('should contain IIPs', function () {
        chai.expect(graphData.connections).to.be.an('array');
        chai.expect(graphData.connections.length).to.equal(5);
        return chai.expect(graphData.connections[0].data).to.be.a('string');
      });
      return it('should contain no exports', function () {
        chai.expect(graphData.exports).to.be.an('array');
        return chai.expect(graphData.exports.length).to.equal(0);
      });
    });
  });
  describe('with FBP string with EXPORTs', function () {
    var fbpData, graphData, parser;
    fbpData = 'EXPORT=READ.IN:FILENAME\nRead(ReadFile) OUT -> IN Display(Output) ';
    graphData = null;
    it('should produce a graph JSON object', function () {
      parser = createParser();
      graphData = parser.parse(fbpData);
      return chai.expect(graphData).to.be.an('object');
    });
    return describe('the generated graph', function () {
      it('should contain two nodes', function () {
        return chai.expect(graphData.processes).to.eql({
          Read: {
            component: 'ReadFile'
          },
          Display: {
            component: 'Output'
          }
        });
      });
      it('should contain a single connection', function () {
        chai.expect(graphData.connections).to.be.an('array');
        chai.expect(graphData.connections.length).to.equal(1);

        return chai.expect(graphData.connections[0]).to.eql({
          src: {
            process: 'Read',
            port: 'out'
          },
          tgt: {
            process: 'Display',
            port: 'in'
          }
        });
      });
      return it('should contain an export', function () {
        chai.expect(graphData.exports).to.be.an('array');
        chai.expect(graphData.exports.length).to.equal(1);
        return chai.expect(graphData.exports[0]).to.eql({
          'private': 'read.in',
          'public': 'filename'
        });
      });
    });
  });
  describe('with FBP string containing node metadata', function () {
    var fbpData, graphData, parser;
    fbpData = 'Read(ReadFile) OUT -> IN Display(Output:foo)\n\n# And we drop the rest\nDisplay() OUT -> IN Drop(Drop:foo)';
    graphData = null;
    it('should produce a graph JSON object', function () {
      parser = createParser();
      graphData = parser.parse(fbpData);
      return chai.expect(graphData).to.be.an('object');
    });
    return describe('the generated graph', function () {
      it('should contain nodes with named routes', function () {
        return chai.expect(graphData.processes).to.eql({
          Read: {
            component: 'ReadFile'
          },
          Display: {
            component: 'Output',
            metadata: {
              routes: ['foo']
            }
          },
          Drop: {
            component: 'Drop',
            metadata: {
              routes: ['foo']
            }
          }
        });
      });
      it('should contain two edges', function () {
        chai.expect(graphData.connections).to.be.an('array');
        return chai.expect(graphData.connections.length).to.equal(2);
      });
      return it('should contain no exports', function () {
        chai.expect(graphData.exports).to.be.an('array');
        return chai.expect(graphData.exports.length).to.equal(0);
      });
    });
  });
  describe('with an invalid FBP string', function () {
    var fbpData, parser;
    fbpData = '\'foo\' -> Display(Output)';
    return it('should fail with an Exception', function () {
      return chai.expect(function () {
        parser = createParser();
        return parser.parse(fbpData);
      }).to['throw'](Error);
    });
  });
  describe('with a component that contains dashes in name', function () {
    var fbpData, graphData, parser;
    fbpData = '\'somefile\' -> SOURCE Read(my-cool-component/ReadFile)';
    graphData = null;
    it('should produce a graph JSON object', function () {
      parser = createParser();
      graphData = parser.parse(fbpData);
      return chai.expect(graphData).to.be.an('object');
    });
    return describe('the generated graph', function () {
      it('should contain one node', function () {
        return chai.expect(graphData.processes).to.eql({
          Read: {
            component: 'my-cool-component/ReadFile'
          }
        });
      });
      return it('should contain an IIP', function () {
        chai.expect(graphData.connections).to.be.an('array');
        return chai.expect(graphData.connections.length).to.equal(1);
      });
    });
  });
  describe('with commas to separate statements', function () {
    var fbpData, graphData, parser;
    fbpData = '\'Hello\' -> IN Foo(Component), \'World\' -> IN Bar(OtherComponent), Foo OUT -> DATA Bar';
    graphData = null;
    it('should produce a graph JSON object', function () {
      parser = createParser();
      graphData = parser.parse(fbpData);
      return chai.expect(graphData).to.be.an('object');
    });
    return describe('the generated graph', function () {
      it('should contain two nodes', function () {
        return chai.expect(graphData.processes).to.eql({
          Foo: {
            component: 'Component'
          },
          Bar: {
            component: 'OtherComponent'
          }
        });
      });
      return it('should contain two IIPs and one edge', function () {
        return chai.expect(graphData.connections).to.eql([{
          data: 'Hello',
          tgt: {
            process: 'Foo',
            port: 'in'
          }
        }, {
          data: 'World',
          tgt: {
            process: 'Bar',
            port: 'in'
          }
        }, {
          src: {
            process: 'Foo',
            port: 'out'
          },
          tgt: {
            process: 'Bar',
            port: 'data'
          }
        }]);
      });
    });
  });

  describe('with underscores and numbers in ports, nodes, and components', function () {
    var fbpData, graphData, parser;
    fbpData = '\'Hello 09\' -> IN_2 Foo_Node_42(Component_15)';
    graphData = null;
    it('should produce a graph JSON object', function () {
      parser = createParser();
      graphData = parser.parse(fbpData);
      return chai.expect(graphData).to.be.an('object');
    });
    return describe('the generated graph', function () {
      it('should contain one node', function () {
        return chai.expect(graphData.processes).to.eql({
          Foo_Node_42: {
            component: 'Component_15'
          }
        });
      });
      return it('should contain an IIP', function () {
        chai.expect(graphData.connections).to.be.an('array');
        chai.expect(graphData.connections.length).to.equal(1);
        return chai.expect(graphData.connections[0]).to.eql({
          data: 'Hello 09',
          tgt: {
            process: 'Foo_Node_42',
            port: 'in_2'
          }
        });
      });
    });
  });

  describe('with array index on ports', function () {
    var fbpData, graphData, parser;
    fbpData = '\'Hello 09\' -> [0] IN_2 Foo_Node_42(Component_15) OUT [9] -> [1] IN Some(Comp)';
    graphData = null;
    it('should produce a graph JSON object', function () {
      parser = createParser();
      graphData = parser.parse(fbpData);
      chai.expect(graphData).to.be.an('object');
    });
    describe('the generated graph', function () {
      it('should contain two nodes', function () {
        chai.expect(Object.keys(graphData.processes).length).to.eql(2);
      });
      it('the nodes should have an input and output index', function () {
        chai.expect(graphData.connections).to.eql([{
          'data': 'Hello 09',
          'tgt': {
            'port': 'in_2',
            'process': 'Foo_Node_42',
            'index': 0
          }
        }, {
          'src': {
            'process': 'Foo_Node_42',
            'port': 'out', // converted to lowercase correct?
            'index': 9
          },
          'tgt': {
            'process': 'Some',
            'port': 'in',
            'index': 1
          }
        }]);
      });
    });
  });
});
