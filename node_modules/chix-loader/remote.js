'use strict';

var Loader = require('./loader');
var request = require('superagent');
var util = require('util');
var async = require('async');
var loadFile = require('./lib/loadFile');
var debug = require('debug')('chix-loader');

function RemoteLoader() {
  // Call the super's constructor
  Loader.apply(this, arguments);

  // keeps track of flows we will have to get definitions for
  this.workload = [];

  this.defaultProvider = 'http://serve-chix.rhcloud.com/nodes/{ns}/{name}';

  debug('Default provider is %s', this.defaultProvider);
}

util.inherits(RemoteLoader, Loader);

/**
 *
 * Initialize the nodeDefinitions
 *
 * Initializing unknown providers
 *
 * The nodeDefinitions keys resemble the namespace.
 *
 * Note: A loader should never manually set a default provider.
 * The flow should already contain an @ section, if it doesn't
 * It means that flow is broken. Fbpx _does_ add a default provider
 * automatically, but it's the json generator, so it's allowed to
 * do so.
 *
 * @param {Object} map
 */
RemoteLoader.prototype.initProviderMap = function(map) {
  var provider;
  var key;

  // ensure a default provider here,
  // if for instance an included subflow does not have
  // a default provider, we are gonna make one up.
  // if that's not desired, the subflow should have provided
  // it's own one.

  if (!map.hasOwnProperty('providers')) {
    map.providers = {};
  }

  if (!map.providers.hasOwnProperty('@')) {
    map.providers['@'] = {
      url: this.defaultProvider
    };
  }

  for (key in map.providers) {
    if (map.providers.hasOwnProperty(key)) {
      provider = map.providers[key];

      // we only deal with remote providers.
      if (provider.hasOwnProperty('url')) {
        if (!this.nodeDefinitions.hasOwnProperty(provider.url)) {
          this.nodeDefinitions[provider.url] = {};
        }
      } else if (provider.hasOwnProperty('path')) {
        if (!this.nodeDefinitions.hasOwnProperty(provider.path)) {
          this.nodeDefinitions[provider.path] = {};
        }
      }
    }
  }
};

/**
 *
 * Just load the whole map.
 * All remote needs is the providers sections and the nodes.
 *
 * Use `update` whenever you expect subflows or nodeDefinitions
 * have changed changed.
 *
 * @param {Object} maps
 * @param {Function} callback
 * @param {Boolean} update
 * @param {Object} dependencies
*/
RemoteLoader.prototype.load = function(maps, callback, update, dependencies) {
  if (!Array.isArray(maps)) {
    maps = [maps];
  }

  // do our private loading.
  this._loadRemote(maps, callback, update, dependencies);
};

/**
 *
 * Preloads all definitions at a providers location.
 *
 * From a remote api this is relatively easy,
 * It also understands the filesystem in which case we just use globbing
 *
 * For a remote api we can assume the structure is just correct ofcourse.
 *
 * But for the file system some extra checks are made to ensure what we
 * are loading are actually component definitions.
 *
 * This method is used to prefill our loader, which means it will
 * hold more definitions then our registered nodes need.
 *
 * In that matter, a clean unused definitions would be handy.
 *
 * Provider is in the form of:
 *
 *   - http://serve.chix.io/nodes/{ns}/{name}
 *   - ./nodes/{ns}/{name}.json
 *   - /var/lib/chix/nodes/{ns}/{name}.fbp
 *
 * An optional second parameter can give a full url at which *all*
 * definitions can be loaded.
 *
 * e.g. http://serve.chix.io/nodes
 *
 * For loading from the filesystem, it's just interpolated.
 *
 * @param {Object} conf
 * @param {String} conf.provider   provider url
 * @param {String} conf.collection endpoint to get full collection
 * @param {Function} callback
 *
 */
// ok I now just use 'x' for provider, then manually add them
// to every node added (for noflo-ui)
RemoteLoader.prototype.preload = function(conf, cb) {
  if (!conf.provider) {
    throw Error('missing provider value');
  }

  if (!conf.collection) {
    throw Error('missing collection value');
  }

  var self = this;

  // load collection and add nodefinitions.
  debug('Preload collection %s', conf.collection);
  request.get(conf.collection, function(err, res) {
    if (err) {
      cb.apply(self, err);
    } else if (res.clientError) {
      cb.apply(self, res.error);
    } else {
      var nodeDef = JSON.parse(res.text);
      self.addNodeDefinitions(conf.provider, nodeDef);
      cb.apply(
        self, [
          null,
          conf.provider,
          self.nodeDefinitions[conf.provider]
        ]
      );
    }
  });
};

RemoteLoader.prototype._loadRemote =
  function(maps, callback, update, dependencies) {

    var j;
    var provider;
    var providerLocation;
    var providerDef;
    var workload = [];
    var self = this;
    var node;
    var remote;
    var willLoad = [];

    if (!dependencies) {
      dependencies = {};
    }

    // loop the nodes, detect what provider they expect
    // if they do not have a provider we will use
    // the default, however, if the flow has set it's own
    // default we will use that.
    // the default within a flow is the one without namespace

    maps.forEach(function(map) {
    // Todo for subflows this runs every time.
    self.initProviderMap(map);

    // Loop all nodes from this flow
    for (j = 0; j < map.nodes.length; j++) {
      node = map.nodes[j];

      // select the name e.g. x
      provider = node.provider ? node.provider : '@';

      // TODO: this rule should be a bit more clear.
      // provider can either be a short name or a full url.
      if (/^(\w|@)+$/.test(provider) === false) {

        // it's already an url or path
        providerLocation = provider;
        remote = true;

      } else {

        if (!map.providers.hasOwnProperty(provider)) {
          callback(Error([
            'Node', node.ns + ':' + node.name,
            'refers to unknown provider',
            provider,
            '\n\tplease specify it in the providers section'
          ].join(' ')));
        }

        // Within the map detect what url x is about
        if (map.providers[provider].hasOwnProperty('path')) {
          // hacked in, remote also takes care of local for now.
          // just refactor this later on.
          providerLocation = map.providers[provider].path;
          remote = false;

        } else if (map.providers[provider].hasOwnProperty('url')) {

          providerLocation = map.providers[provider].url;
          remote = true;

        } else {
          callback(Error('Do not know how to handle: ' + provider));
        }
      }

      // The nodeDefinition this url already carries
      if (self.nodeDefinitions[providerLocation]) {
        providerDef = self.nodeDefinitions[providerLocation];
      } else {
        providerDef = self.nodeDefinitions[providerLocation] = {};
      }

      // Consider it loaded, this is the central registration of nodes.
      // loader-nosql also relies on this. So maybe refactor later.
      // ok, this is not going correctly for subflow.
      // The reason is, we are not recursiving if the definitions
      // are already loaded. We will have to do the same logic
      // for nosql, the recursive loading...

      // The node definition could be known if e.g. loader-nosql has already
      // provided it for us.
      if (!self.hasNodeDefinition(providerLocation, node.ns, node.name) &&
        !update) {
        // load the definition for us
        var location = providerLocation.replace('{ns}', node.ns).
          replace('{name}', node.name);

        // Check if it carries the info for our node also.
        if (willLoad.indexOf(location) === -1 &&
           (!providerDef.hasOwnProperty(node.ns) ||
           !providerDef.hasOwnProperty(node.name))) {

          willLoad.push(location);

          if (remote) {
            workload.push({
              url: location,
              ns: node.ns,
              name: node.name,
              providerLocation: providerLocation
            });
          } else {
            workload.push({
              path: location,
              ns: node.ns,
              name: node.name,
              providerLocation: providerLocation
            });
          }
        }
      }
    }

  });

    // Only load if there are any urls to load

    if (workload.length) {

      async.map(workload, this.loadNode.bind(this), function(err, result) {

        if (err) {

          // TODO: this returns the wrong url.
          callback(err);

        } else {

          var maps = [];

          // Loop all loaded node definitions
          for (var i = 0; i < result.length; i++) {

            var nodeDef = result[i].nodeDef;

            // Any extenders can now save this result
            self.saveNodeDefinition(result[i].providerLocation, nodeDef);

            // Add the nodedefinition
            self.addNodeDefinition(result[i].providerLocation, nodeDef);

            dependencies = self._parseDependencies(dependencies, nodeDef);

            // is the node is a flow, push to the workload.
            // how to do this for known nodes?
            if (nodeDef.type === 'flow') {

              var flow = nodeDef;

              if (!flow.ns) {
                callback(
                  Error(
                    util.format('No Namespace found for Flow %s', flow.title)
                  )
                );
              }

              if (!flow.name) {
                callback(
                  Error(util.format('No Name found for Flow %s', flow.title))
                );
              }

              // self.workload.push(flow);
              maps.push(flow);

            }

          }

          // always continue loading even if maps is empty.
          self._loadRemote(maps, callback, update, dependencies);

        }

      });

    } else {

      callback(null, {
      dependencies: dependencies,
      // do not care so much if all nodeDefinitions are given.
      nodeDefinitions: this.nodeDefinitions
    });

    }

  };

/**
*
* Remote loader does not store it's definitions
*
*/
RemoteLoader.prototype.saveNodeDefinition = function() {

  // nop

};

/**
 *
 * Loads the node
 *
 * Either remote, if there is an url property.
 * Or else tries to load the file if there is a path property.
 *
 * var d = {
 *   url: || path:      - the location
 *   providerLocation:  - provider url
 * }
 *
 * url & path is just the provider url with it's variables filled in.
 *
 * @param {object} d
 * @param {Function} cb
 */
RemoteLoader.prototype.loadNode = function(d, cb) {

  if (d.hasOwnProperty('url')) {
    this.loadUrl(d, cb);
  } else if (d.hasOwnProperty('path')) {
    this.loadFile(d, cb);
  } else {
    cb(Error('Do not know how to load node'));
  }
};

/**
 *
 * Loads a local file
 *
 * @param {object} d
 * @param {Function} cb
 */
RemoteLoader.prototype.loadFile = function(d, cb) {

  this.emit('loadFile', {path: d.path});

  loadFile(d, cb);
};

/**
 *
 * Loads a nodeDefinition URL
 *
 * @param {object} d
 * @param {Function} cb
 */
RemoteLoader.prototype.loadUrl = function(d, cb) {

  this.emit('loadUrl', {
    url: d.url
  });

  request.get(d.url, function(err, res) {

    if (err) {
      cb(err);
    } else {

      if (res.clientError) {
        cb(res.error);
      } else if (/^\s*{/.test(res.text)) { // test for json

        var data = JSON.parse(res.text);

        cb(null, {
          providerLocation: this.providerLocation,
          nodeDef: data
        });

      } else {
        cb(util.format(
          'URL did not return a valid JSON Document: %s', this.url
        ));
      }
    }

  }.bind({
    providerLocation: d.providerLocation,
    url: d.url
  }));

};

module.exports = RemoteLoader;
