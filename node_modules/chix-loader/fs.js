'use strict';

var LoaderRemote = require('./remote');
var util = require('util');
var fs = require('fs');
var syncer;

function nop() {}

/**
*
*  Loads and saves definitions from/to the local cache file.
*
*/
function FSLoader(opts) {

  if (!(this instanceof FSLoader)) {
    return new FSLoader(opts);
  }

  opts = opts || {};

  this.opts = {};
  this.opts.cache = !!opts.cache;
  this.opts.purge = !!opts.purge;

  // Call the super's constructor
  LoaderRemote.apply(this, arguments);

  this._cacheFile = './.x.cache';

  // purge the cache file
  if (this.opts.purge) {

    try {
      fs.unlinkSync(this._cacheFile);

      this.emit('purgeCache', {
        file: this._cacheFile
      });

    } catch (e) {
      nop(e);
    }

  }

  if (this.opts.cache && !this.opts.purge) {

    if (syncer) {
      process.removeListener('exit', syncer);
    } else {
      // re-used
      process.on('SIGINT', function() {
        process.exit();
      });
    }

    syncer = this.syncState.bind(this);
    process.on('exit', syncer);
  }

}

util.inherits(FSLoader, LoaderRemote);

/**
*
*  Loads all definitions from the database.
*  Any missing pieces will be loaded by remote Loader.
*
*  If you use `update` all definitions in the database will be refreshed.
*
* @param {Object} map
* @param {Function} callback
* @param {Boolean} update
*/
FSLoader.prototype.load = function(map, callback, update) {
  var self = this;

  // save internal state to disk
  fs.exists(this._cacheFile, function(exists) {
    if (exists && self.opts.cache) {
      try {
        fs.readFile(self._cacheFile, function(err, content) {

          var res = JSON.parse(content);
          // todo: dangerous bit here
          self.dependencies = res.dependencies || {};

          self.nodes = res.nodes;
          self.nodeDefinitions = res.nodeDefinitions;
          //self.addNodeDefinition(nodeDef.provider, nodeDef);

          self.emit('loadCache', {
            file: self._cacheFile,
            cache: res // maybe a bit too much, ah well
          });

          // Start the remote loader, It will not load any known definitions.
          LoaderRemote.prototype.load.apply(self, [map, callback, update]);

        });
      } catch (e) {
        callback(Error('Error loading ' + self._cacheFile));
      }
    } else {
      LoaderRemote.prototype.load.apply(self, [map, callback, update]);
    }
  });
};

/**
 *
 * Saves the internal state to disk
 *
 * @param {Object} map
 * @param {Function} callback
 */
FSLoader.prototype.syncState = function() {
  // save internal state to disk
  fs.writeFileSync(this._cacheFile, JSON.stringify({
    dependencies: this.dependencies,
    nodes: this.nodes,
    nodeDefinitions: this.nodeDefinitions
  }));

  this.emit('writeCache', {
    file: this._cacheFile
  });
};

module.exports = FSLoader;
